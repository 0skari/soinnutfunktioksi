<!DOCTYPE html>
<html lang="fi">
<head>
  <meta charset="UTF-8">
  <title>Soinnun sävelet sinifunktion jaksolliseen aaltomuotoon lineaarialgebran superpositioperiaattetta noudattaen</title>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    .note { margin-bottom: 5px; }
    .note input[type="range"] { width: 200px; }
    .selected-notes { margin-top: 10px; }
    #latex-box { white-space: pre-wrap; margin-top: 20px; background: #f0f0f0; padding: 10px; border-radius: 8px; }
  </style>
</head>
<body>

<h3>Soinnun sävelet sinifunktion jaksolliseen aaltomuotoon lineaarialgebran superpositioperiaattetta noudattaen:</h3>

<label for="A_a">Yleinen amplitudi A<sub>α</sub> (0–2): </label>
<input type="range" id="A_a" min="0" max="2" step="0.01" value="1">
<span id="A_a_val">1</span>

<h2>Valitse sävelet:</h2>
<select id="note-selector">
  <option value="">Valitse sävel</option>
</select>
<button onclick="addNote()">Lisää sävel</button>

<div class="selected-notes" id="selected-notes"></div>

<h2>LaTeX-kaava:</h2>
<div id="latex-box"></div>

<script>
  const noteNames = [
    "A 0","Ais 0","H 0",
    "C 1","Cis 1","D 1","Dis 1","E 1","F 1","Fis 1","G 1","Gis 1",
    "A 1","Ais 1","H 1",
    "C 2","Cis 2","D 2","Dis 2","E 2","F 2","Fis 2","G 2","Gis 2",
    "A 2","Ais 2","H 2",
    "C 3","Cis 3","D 3","Dis 3","E 3","F 3","Fis 3","G 3","Gis 3",
    "A 3","Ais 3","H 3",
    "C 4","Cis 4","D 4","Dis 4","E 4","F 4","Fis 4","G 4","Gis 4",
    "A 4","Ais 4","H 4",
    "C 5","Cis 5","D 5","Dis 5","E 5","F 5","Fis 5","G 5","Gis 5",
    "A 5","Ais 5","H 5",
    "C 6","Cis 6","D 6","Dis 6","E 6","F 6","Fis 6","G 6","Gis 6",
    "A 6","Ais 6","H 6",
    "C 7","Cis 7","D 7","Dis 7","E 7","F 7","Fis 7","G 7","Gis 7",
    "A 7","Ais 7","H 7",
    "C 8"
  ];

  const selectedNotes = [];
  const A_n = {};

  const noteSelector = document.getElementById("note-selector");
  noteNames.forEach((note, i) => {
    const option = document.createElement("option");
    option.value = i - 48;
    option.text = `${note} (n = ${i - 48})`;
    noteSelector.appendChild(option);
  });

  document.getElementById("A_a").addEventListener("input", () => {
    document.getElementById("A_a_val").innerText = document.getElementById("A_a").value;
    updateLatex();
  });

  function addNote() {
    const selector = document.getElementById("note-selector");
    const value = selector.value;
    if (value === "" || selectedNotes.includes(value)) return;

    selectedNotes.push(value);
    A_n[value] = 1;

    const container = document.createElement("div");
    container.className = "note";
    container.id = `note_${value}`;
    const noteIndex = parseInt(value) + 48;
    const noteName = noteNames[noteIndex];
    container.innerHTML = `
      Sävel ${noteName} (n = ${value}), sävelen amplitudi: &nbsp;
      <input type="range" min="0" max="2" step="0.01" value="1"
        oninput="updateAn('${value}', this.value)">
      <span id="A_n_val_${value}">1</span>
      <button onclick="removeNote('${value}')">Poista</button>
    `;

    document.getElementById("selected-notes").appendChild(container);
    updateLatex();
  }

  function removeNote(value) {
    document.getElementById(`note_${value}`).remove();
    const index = selectedNotes.indexOf(value);
    if (index > -1) selectedNotes.splice(index, 1);
    delete A_n[value];
    updateLatex();
  }

  function updateAn(value, amp) {
    A_n[value] = amp;
    document.getElementById(`A_n_val_${value}`).innerText = amp;
    updateLatex();
  }

  function updateLatex() {
      const A_a = document.getElementById("A_a").value;
      let parts = selectedNotes.map(n =>
        `\\frac{${A_n[n]}}{2}\\cdot\\sin\\left(2\\pi\\cdot 440\\cdot2^{\\frac{${n}}{12}}\\cdot x\\right)`
      );
      let latex = `\\[\\frac{${A_a}}{2}\\cdot\\left(${parts.join(" + ")}\\right)\\]`;

      document.getElementById("latex-box").innerText = latex;
      MathJax.typesetPromise([document.getElementById("latex-box")]);
  }
</script>

<p><span style="color: #000000;">Kopioi LaTeX: Napauta kaavaa oikealla korvalla -&gt; Copy to clipboard -&gt; TeX Commands. Muista poistaa koodin edest&auml; "\displaystyle ", mik&auml;li aiot k&auml;ytt&auml;&auml; kaavaa <a style="color: #000000;" title="Kaavaeditori" href="https://kaava.mafynetti.fi/" target="_blank">kaavaeditorissa</a>.</span></p>

</p>Perustuu kaavaan:</p>

<p>  
\(\displaystyle f_i = A4\ \cdot \sqrt[12]{2}^{\,n_i}\)
</p>

<p>  
\(\displaystyle \text{Sointu}(x)=\frac{A_{\alpha }}{2}\cdot \sum _{i=0}^k\left(\frac{\sin \left(2\pi \cdot 440\cdot 2^{\frac{n_i}{12}}\cdot x\right)}{\left(\frac{A_{n_i}}{2}\right)^{-1}}\right)\)
</p>

<p>  
\(\displaystyle => \frac{A_{\alpha }}{2}\cdot \left(\frac{A_{n_0}}{2}\cdot \sin \left(2\pi \cdot 440\cdot 2^{\frac{n_0}{12}}\cdot x\right)+\frac{A_{n_1}}{2}\cdot \sin \left(2\pi \cdot 440\cdot 2^{\frac{n_1}{12}}\cdot x\right)+...+\frac{A_{n_k}}{2}\cdot \sin \left(2\pi \cdot 440\cdot 2^{\frac{n_k}{12}}\cdot x\right)\right)\)
</p>




<p>  
\(\displaystyle \text{Missä:}\)
</p>
<p>  
\(\displaystyle \text{- }A4\ \text{-sävelen taajuus on 440 Hz käytettäessä tasavireistä viritysjärjestelmää (12-TET; 12 tone equal temperament),}\)
</p>
<p>  
\(\displaystyle \text{- }A\ \text{on aallon amplitudi,}\)
</p>
<p>  
\(\displaystyle \text{- }{\alpha}\ \text{on soinnun aalto kokonaisuudessaan,}\)
</p>
<p>  
\(\displaystyle \text{- }k\ \text{on soinnun sävelten kokonaislukumäärä,}\)
</p>
<p>  
\(\displaystyle \text{- }n_i\ \text{on sävelen}\ i \text{ "matka" sävelestä A4 puolisävelaskelissa, missä}\ i=0{,}\ 1{,}...{,}\ k-1,\)
</p>
<p>  
\(\displaystyle \text{- }f_i\ \text{on sävelen}\ i \text{ taajuus, missä}\ i=0{,}\ 1{,}...{,}\ k-1,\)
</p>
<p>  
\(\displaystyle \text{- }x\ \text{on aika sekunteina.}\)
</p>


</body>
</html>


----------------------------------


<!DOCTYPE html>
<html lang="fi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>LaTeX yhtälöstä ääni, kuvaaja ja soitettava aaltomuoto</title>
<script src="https://cdn.jsdelivr.net/npm/mathjs@11.8.0/lib/browser/math.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<style>
  body { font-family: Arial, sans-serif; padding: 1em; background: #fafafa; }
  textarea { width: 100%; height: 6em; font-family: monospace; font-size: 1.1em; }
  canvas { border: 1px solid #333; width: 100%; height: 200px; background: white; display: block; margin-top: 1em; }
  button { padding: 0.5em 1em; margin-top: 1em; font-size: 1em; cursor: pointer; }
  #outputLatex { font-size: 1.2em; margin-top: 1em; min-height: 1.5em; }
  #log { color: red; margin-top: 1em; min-height: 1.2em; font-family: monospace; white-space: pre-wrap; }
</style>
</head>
<body>

<h1>LaTeX yhtälöstä ääni, kuvaaja ja soitettava aaltomuoto</h1>

<p>Liitä LaTeX-muotoinen yhtälö, joka sisältää muuttujan <code>x</code> (esim. <code>\sin \left(2\pi \cdot 440\cdot 2^{\frac{0}{12}}\cdot x\right)</code>)</p>
<textarea id="latexInput" placeholder="Kopioi LaTeX: Napauta kaavaa oikealla korvalla -> Copy to clipboard -> TeX Commands JA liitä LaTeX-yhtälö tähän ilman \displaystyle-kohtaa."></textarea>

<button id="processBtn">Sievennä, piirrä ja soita</button>

<div id="outputLatex"></div>
<div id="log"></div>

<canvas id="waveCanvas" width="800" height="200"></canvas>
<canvas id="visualizerCanvas" width="800" height="200"></canvas>

<script>
  const latexInput = document.getElementById('latexInput');
  const outputLatex = document.getElementById('outputLatex');
  const log = document.getElementById('log');
  const waveCanvas = document.getElementById('waveCanvas');
  const waveCtx = waveCanvas.getContext('2d');
  const visualizerCanvas = document.getElementById('visualizerCanvas');
  const visualizerCtx = visualizerCanvas.getContext('2d');
  const btn = document.getElementById('processBtn');

  let audioCtx = null;
  let analyser = null;
  let source = null;
  let animationId = null;

  function logMsg(msg) {
    log.textContent = msg;
    console.log(msg);
  }

  function latexToMathjs(latex) {
    let expr = latex;

    // Korvaa \frac{a}{b} muotoon (a/b)
    while (expr.match(/\\frac\s*\{([^{}]+)\}\s*\{([^{}]+)\}/)) {
      expr = expr.replace(/\\frac\s*\{([^{}]+)\}\s*\{([^{}]+)\}/g, '($1/$2)');
    }

    // Korvaa potenssit: a^{b} -> a^(b)
    expr = expr.replace(/(\S)\s*\^\s*\{([^{}]+)\}/g, '$1^($2)');

    // Poista LaTeXin \cdot, \left, \right
    expr = expr.replace(/\\cdot/g, '*');
    expr = expr.replace(/\\left/g, '');
    expr = expr.replace(/\\right/g, '');

    // Korvaa trigonometriset funktiot
    expr = expr.replace(/\\sin/g, 'sin');
    expr = expr.replace(/\\cos/g, 'cos');
    expr = expr.replace(/\\tan/g, 'tan');

    // Korvaa pi
    expr = expr.replace(/\\pi/g, 'pi');

    return expr;
  }

  // Pyöristää numerot 3 desimaalin tarkkuuteen sievennetystä lausekkeesta
  function roundConstants(node, decimals = 3) {
    return node.transform(function (node, path, parent) {
      if (node.isConstantNode) {
        const val = Number(node.value);
        if (!isNaN(val)) {
          return new math.ConstantNode(parseFloat(val.toFixed(decimals)));
        }
      }
      return node;
    });
  }

  function getScaledSamples(f, sampleCount, sampleRate) {
    const samples = [];
    for (let i = 0; i < sampleCount; i++) {
      const t = i / sampleRate;
      let v;
      try {
        v = f.evaluate({x: t});
      } catch (e) {
        v = 0;
      }
      if (!isFinite(v)) v = 0;
      samples.push(v);
    }
    // Etsi maksimi amplitudi (absoluuttinen arvo)
    const maxAmp = Math.max(...samples.map(s => Math.abs(s))) || 1;
    // Skaalauskerroin, jotta max amplitude on 80% canvasin korkeudesta (korkeus on 1.0 koska samplet ovat +-1)
    const scale = 0.8 / maxAmp;

    // Palautetaan skaalatut arvot ja skaalauskerroin
    const scaledSamples = samples.map(s => s * scale);
    return {scaledSamples, scale};
  }

  function drawWave(f) {
    const width = waveCanvas.width;
    const height = waveCanvas.height;
    waveCtx.clearRect(0, 0, width, height);
    waveCtx.beginPath();
    waveCtx.strokeStyle = 'blue';

    const samplesCount = width;
    const sampleRate = 100; // sopiva sample rate kuvalle
    const {scaledSamples} = getScaledSamples(f, samplesCount, sampleRate);

    for (let i = 0; i < samplesCount; i++) {
      const y = height / 2 - scaledSamples[i] * (height / 2);
      if (i === 0) waveCtx.moveTo(i, y);
      else waveCtx.lineTo(i, y);
    }
    waveCtx.stroke();
  }

  function playWave(f) {
    logMsg("Ladataan ääntä...");
    if (!window.AudioContext) {
      alert("AudioContext ei ole tuettu tässä selaimessa.");
      return;
    }

    if (!audioCtx) {
      audioCtx = new AudioContext();
    }

    if (audioCtx.state === 'suspended') {
      audioCtx.resume().then(() => {
        logMsg("AudioContext aktivoitu.");
        startPlay();
      });
    } else {
      startPlay();
    }

    function startPlay() {
      if (source) {
        try {
          source.stop();
          source.disconnect();
        } catch {}
      }
      if (animationId) {
        cancelAnimationFrame(animationId);
      }

      const sampleRate = audioCtx.sampleRate || 44100;
      const duration = 2;  // 1 sekunti
      const frameCount = sampleRate * duration;

      // Lasketaan kaikki sample-arvot ja skaalataan
      const {scaledSamples, scale} = getScaledSamples(f, frameCount, sampleRate);

      const buffer = audioCtx.createBuffer(1, frameCount, sampleRate);
      const data = buffer.getChannelData(0);

      for (let i = 0; i < frameCount; i++) {
        let v = scaledSamples[i];
        if (v > 1) v = 1;
        else if (v < -1) v = -1;
        data[i] = v;
      }

      source = audioCtx.createBufferSource();
      source.buffer = buffer;

      source.loop = true;  // Loopataan ääni

      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      source.connect(analyser);
      analyser.connect(audioCtx.destination);

      source.start();
      logMsg(`Ääni käynnistetty loopilla (skaalauskerroin ${scale.toFixed(3)}).`);

      visualize();
    }
  }

  function visualize() {
    const width = visualizerCanvas.width;
    const height = visualizerCanvas.height;
    analyser.fftSize = 2048;
    const bufferLength = analyser.fftSize;
    const dataArray = new Uint8Array(bufferLength);

    function draw() {
      animationId = requestAnimationFrame(draw);

      analyser.getByteTimeDomainData(dataArray);

      visualizerCtx.fillStyle = 'white';
      visualizerCtx.fillRect(0, 0, width, height);

      visualizerCtx.lineWidth = 2;
      visualizerCtx.strokeStyle = 'green';
      visualizerCtx.beginPath();

      const sliceWidth = width * 1.0 / bufferLength;
      let x = 0;

      for (let i = 0; i < bufferLength; i++) {
        const v = dataArray[i] / 128.0; // 0..2
        const y = v * height / 2;

        if (i === 0) {
          visualizerCtx.moveTo(x, y);
        } else {
          visualizerCtx.lineTo(x, y);
        }

        x += sliceWidth;
      }

      visualizerCtx.lineTo(width, height / 2);
      visualizerCtx.stroke();
    }

    draw();
  }

  btn.addEventListener('click', async () => {
    logMsg(""); // tyhjennä logi
    waveCtx.clearRect(0, 0, waveCanvas.width, waveCanvas.height);
    visualizerCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);

    const latex = latexInput.value.trim();
    if (!latex) {
      alert("Syötä LaTeX-muotoinen yhtälö!");
      return;
    }

    const mathjsExpr = latexToMathjs(latex);
    console.log("MathJS expr:", mathjsExpr);

    let parsed;
    try {
      parsed = math.parse(mathjsExpr);
    } catch (e) {
      alert("Virhe lausekkeessa: " + e.message);
      console.error(e);
      return;
    }

    let simplified;
    try {
      simplified = math.simplify(parsed);
      simplified = roundConstants(simplified, 3);
    } catch(e) {
      alert("Virhe sievennyksessä: " + e.message);
      console.error(e);
      return;
    }

    outputLatex.innerHTML = 'Sievennetty lauseke: $$' + simplified.toTex() + '$$';
    await MathJax.typesetPromise();

    // Testataan evaluointi yhdellä arvolla
    try {
      let testVal = simplified.evaluate({x: 0.01});
      console.log("Testi evaluate x=0.01:", testVal);
      if (!isFinite(testVal)) {
        throw new Error("Evaluointi tuotti ei-numeraalisen arvon.");
      }
    } catch(e) {
      alert("Lausekkeen evaluointi epäonnistui: " + e.message);
      console.error(e);
      return;
    }

    drawWave(simplified);

    playWave(simplified);
  });
</script>

</body>
</html>

----------------------------------

<!DOCTYPE html>
<html lang="fi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Negative Harmony Visualizer</title>
<style>
  body { font-family: Arial, sans-serif; text-align: center; margin: 20px; }
  svg { border: 1px solid #ccc; margin-top: 20px; user-select:none; }
  circle.note {
    cursor: pointer;
    stroke: black;
    stroke-width: 1;
    transition: fill 0.3s;
  }
  line.axisSegment {
    stroke: gray;
    stroke-width: 5;
    cursor: pointer;
    opacity: 0.4;
    transition: opacity 0.3s, stroke 0.3s;
  }
  line.axisSegment:hover {
    opacity: 1;
    stroke: darkorange;
  }
  line.axisLine {
    stroke: black;
    stroke-width: 3;
  }
  text {
    user-select: none;
    font-weight: bold;
    font-size: 22px;
    pointer-events: none;
  }
  button {
    margin: 10px 8px 0 8px;
    font-size: 16px;
    padding: 8px 15px;
  }
  #info {
    margin-bottom: 10px;
    font-size: 18px;
  }
</style>
</head>
<body>

<h1>Negative Harmony Visualizer</h1>
<div id="info">1. Please choose the axis the chord.</div>

<svg id="circle" width="64vh" height="90vh%" viewBox="-250 -250 500 500">
  <circle cx="0" cy="0" r="195" fill="#f5f5f5" stroke="black" stroke-width="2"/>
</svg>

<div>
  <button id="startMarkingBtn" disabled>2. Lock the position of the axis</button>
  <button id="mirrorBtn" disabled>3. Continue</button>
  <button id="resetBtn">Reset</button>
</div>

<script>
  const SVG_NS = "http://www.w3.org/2000/svg";
  const svg = document.getElementById('circle');
  const radius = 200;
  const notes = [
    'C(Am)', 'G(Em)', 'D(Hm)', 'A(F♯m)', 'E(C♯m)',
    'H(C♭&G♯m)', 'F♯(G♭&E♭m)', 'D♭(C♯&Bm)', 'A♭(Fm)',
    'E♭(Cm)', 'B(Gm)', 'F(Dm)'
  ];

  const points = [];
  const noteElements = [];
  const axisSegments = [];
  const noteAxisSegments = [];

  let mode = 'chooseAxis';
  let axisIndices = null;
  let axis = null;
  const redNotes = new Set();

  const infoText = document.getElementById('info');
  const startMarkingBtn = document.getElementById('startMarkingBtn');
  const mirrorBtn = document.getElementById('mirrorBtn');
  const resetBtn = document.getElementById('resetBtn');

  // Draw notes
  for (let i = 0; i < notes.length; i++) {
    const angle = (i / notes.length) * 2 * Math.PI - Math.PI / 2;
    const x = radius * Math.cos(angle);
    const y = radius * Math.sin(angle);
    points.push({ x, y });

    const circle = document.createElementNS(SVG_NS, "circle");
    circle.setAttribute("cx", x);
    circle.setAttribute("cy", y);
    circle.setAttribute("r", 40);
    circle.classList.add('note');
    circle.setAttribute('fill', 'white');
    circle.setAttribute('data-index', i);
    svg.appendChild(circle);

    // Teksti, jossa sulut erivärisinä/pienempinä
    const text = document.createElementNS(SVG_NS, "text");
    text.setAttribute("x", x);
    text.setAttribute("y", y + 6);
    text.setAttribute("text-anchor", "middle");

    const match = notes[i].match(/^([^()]+)(\(.*\))?$/);
    if (match) {
      const normalPart = match[1];
      const bracketPart = match[2];

      const normalTspan = document.createElementNS(SVG_NS, "tspan");
      normalTspan.textContent = normalPart;
      text.appendChild(normalTspan);

      if (bracketPart) {
        const bracketTspan = document.createElementNS(SVG_NS, "tspan");
        bracketTspan.textContent = bracketPart;
        bracketTspan.setAttribute("fill", "green");
        bracketTspan.setAttribute("font-size", "10"); // pienempi fontti
        text.appendChild(bracketTspan);
      }
    } else {
      text.textContent = notes[i];
    }

    svg.appendChild(text);
    noteElements.push(circle);
  }

  // Axis between notes
  for (let i = 0; i < notes.length; i++) {
    const p1 = points[i];
    const p2 = points[(i + 1) % notes.length];

    const line = document.createElementNS(SVG_NS, "line");
    line.setAttribute("x1", p1.x);
    line.setAttribute("y1", p1.y);
    line.setAttribute("x2", p2.x);
    line.setAttribute("y2", p2.y);
    line.classList.add('axisSegment');
    line.setAttribute('data-type', 'between');
    line.setAttribute('data-start', i);
    line.setAttribute('data-end', (i + 1) % notes.length);
    svg.appendChild(line);
    axisSegments.push(line);

    line.addEventListener('click', () => {
      if (mode !== 'chooseAxis') return;
      axisIndices = [i, (i + 1) % notes.length];
      selectAxis(axisIndices, 'between');
    });
  }

  // Axis through note
  for (let i = 0; i < notes.length; i++) {
    const p1 = points[i];
    const p2 = points[(i + 6) % notes.length]; // opposite note

    const line = document.createElementNS(SVG_NS, "line");
    line.setAttribute("x1", p1.x);
    line.setAttribute("y1", p1.y);
    line.setAttribute("x2", p2.x);
    line.setAttribute("y2", p2.y);
    line.classList.add('axisSegment');
    line.setAttribute('data-type', 'through');
    line.setAttribute('data-note', i);
    svg.appendChild(line);
    noteAxisSegments.push(line);

    line.addEventListener('click', () => {
      if (mode !== 'chooseAxis') return;
      axisIndices = [i, (i + 6) % notes.length];
      selectAxis(axisIndices, 'through');
    });
  }

  function removeAxisLine() {
    const oldLine = document.getElementById('axisLine');
    if (oldLine) oldLine.remove();
  }

  function selectAxis(indices, type) {
    removeAxisLine();

    if (type === 'between') {
      const a = points[indices[0]];
      const b = points[indices[1]];
      const midX = (a.x + b.x) / 2;
      const midY = (a.y + b.y) / 2;
      axis = {
        start: { x: midX,  y: midY },
        end:   { x: -midX, y: -midY }
      };
    } else {
      const a = points[indices[0]];
      const b = points[indices[1]];
      axis = {
        start: { x: a.x, y: a.y },
        end:   { x: b.x, y: b.y }
      };
    }

    const axisLine = document.createElementNS(SVG_NS, "line");
    axisLine.setAttribute("x1", axis.start.x);
    axisLine.setAttribute("y1", axis.start.y);
    axisLine.setAttribute("x2", axis.end.x);
    axisLine.setAttribute("y2", axis.end.y);
    axisLine.setAttribute("class", "axisLine");
    axisLine.setAttribute("id", "axisLine");
    svg.appendChild(axisLine);

    [...axisSegments, ...noteAxisSegments].forEach(line => {
      line.style.opacity = 0.4;
      line.style.stroke = 'gray';
      line.style.pointerEvents = 'none';
    });

    infoText.textContent = '2. Lock the position of the axis and select the notes for your chord.';
    startMarkingBtn.disabled = false;
  }

  startMarkingBtn.addEventListener('click', () => {
    if (mode !== 'chooseAxis') {
      infoText.textContent = 'You are already selecting chord notes.';
      return;
    }
    if (!axis) {
      infoText.textContent = 'Please choose the axis first.';
      return;
    }
    mode = 'markRed';
    infoText.textContent = 'Select the notes of your chord by clicking on them.';
    startMarkingBtn.disabled = true;
    mirrorBtn.disabled = false;
  });

  mirrorBtn.addEventListener('click', () => {
    if (mode !== 'markRed') {
      infoText.textContent = 'Please select chord notes first.';
      return;
    }
    if (redNotes.size === 0) {
      infoText.textContent = 'Please select at least one note before continuing.';
      return;
    }
    mirrorRedNotes();
    mode = 'mirrored';
    infoText.textContent = 'The chord has been mirrored about the selected axis.';
    mirrorBtn.disabled = true;
  });

  resetBtn.addEventListener('click', () => {
    mode = 'chooseAxis';
    axisIndices = null;
    axis = null;
    redNotes.clear();
    removeAxisLine();
    [...axisSegments, ...noteAxisSegments].forEach(line => {
      line.style.opacity = 0.4;
      line.style.stroke = 'gray';
      line.style.pointerEvents = 'auto';
    });
    noteElements.forEach(c => c.setAttribute('fill', 'white'));
    infoText.textContent = '1. Select the position of the axis with respect to which the chord will be mirrored.';
    startMarkingBtn.disabled = true;
    mirrorBtn.disabled = true;
  });

  noteElements.forEach(circle => {
    circle.addEventListener('click', () => {
      if (mode !== 'markRed') return;
      const idx = parseInt(circle.getAttribute('data-index'));
      if (redNotes.has(idx)) {
        redNotes.delete(idx);
        circle.setAttribute('fill', 'white');
      } else {
        redNotes.add(idx);
        circle.setAttribute('fill', 'pink');
      }
    });
  });

  function mirrorRedNotes() {
    if (!axis) return;

    const axisStart = axis.start;
    const axisEnd = axis.end;

    const dx = axisEnd.x - axisStart.x;
    const dy = axisEnd.y - axisStart.y;
    const len = Math.hypot(dx, dy);
    const ux = dx / len;
    const uy = dy / len;

    function mirrorPoint(p) {
      const apx = p.x - axisStart.x;
      const apy = p.y - axisStart.y;
      const dot = apx * ux + apy * uy;
      const projx = dot * ux;
      const projy = dot * uy;
      return {
        x: p.x - 2 * (apx - projx),
        y: p.y - 2 * (apy - projy)
      };
    }

    const threshold = 25;
    const mirroredIndices = new Set();

    redNotes.forEach(idx => {
      const p = points[idx];
      const mp = mirrorPoint(p);

      let nearestIdx = null;
      let nearestDist = Infinity;
      points.forEach((pt, i) => {
        const d = Math.hypot(pt.x - mp.x, pt.y - mp.y);
        if (d < nearestDist) {
          nearestDist = d;
          nearestIdx = i;
        }
      });

      if (nearestDist < threshold) {
        mirroredIndices.add(nearestIdx);
      }
    });

    mirroredIndices.forEach(idx => {
      if (redNotes.has(idx)) {
        noteElements[idx].setAttribute('fill', 'violet');
      } else {
        noteElements[idx].setAttribute('fill', 'lightblue');
      }
    });
  }
</script>

</body>
</html>

----------------------------------

<!DOCTYPE html>
<html lang="fi">
<head>
  <meta charset="UTF-8">
  <title>Harmoninen Spektrogrammi</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 1em;
      max-width: 1000px;
      margin: auto;
    }
    label {
      display: block;
      margin: 0.5em 0;
    }
    canvas {
      border: 1px solid #ccc;
      margin-top: 1em;
      display: block;
    }
    #slider {
      width: 100%;
    }
  </style>
</head>
<body>
  <h2>Harmoninen spektrogrammi ja live-aaltomuoto</h2>

  <label>Perustaajuus (Hz):
    <input type="number" id="baseFreq" value="220" step="0.1">
  </label>

  <label>Toinen taajuus:
    <input type="range" id="slider" min="50" max="1000" value="220" step="0.1">
    <input type="number" id="freqInput" value="220" step="0.1"> Hz
  </label>

  <label>Tavoitetaajuus (Hz):
    <input type="number" id="targetFreq" value="440" step="0.1">
  </label>

  <label>
    <input type="checkbox" id="autoSlide"> Automatisoi taajuus liukuun
  </label>

  <label>Liukunopeus (Hz/s):
    <input type="number" id="slideSpeed" value="10" step="1" min="1" max="1000">
  </label>

  <label>Harmonioita:
    <input type="number" id="harmonics" value="16" min="1" max="64">
  </label>

  <label>Alkuamplitudi (0–1):
    <input type="number" id="startAmp" value="0.5" step="0.01" min="0.01" max="1.0">
  </label>

  <label>Log-skaalauksen tiukkuus:
    <input type="range" id="logScale" min="0.2" max="5" step="0.1" value="2">
  </label>

  <label>Harmoninen vaimeneminen (eksponentti): 
    <input type="range" id="decay" min="0" max="4" value="1" step="0.1">
    <span id="decayValue">1.0</span>
  </label>

  <button id="playBtn">▶ Soita / Pysäytä</button>

  <h3>Spektrogrammi</h3>
  <canvas id="specCanvas" width="1000" height="500"></canvas>

  <h3>Aaltomuoto (waveform)</h3>
  <canvas id="waveCanvas" width="1000" height="200"></canvas>

  <script>
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const ctx = new AudioContext();

    let osc1 = [], osc2 = [], isPlaying = false;
    const slider = document.getElementById('slider');
    const freqInput = document.getElementById('freqInput');
    const baseFreqInput = document.getElementById('baseFreq');
    const harmonicsInput = document.getElementById('harmonics');
    const startAmpInput = document.getElementById('startAmp');
    const logScaleInput = document.getElementById('logScale');
    const decayInput = document.getElementById('decay');
    const decayValueDisplay = document.getElementById('decayValue');
    const playBtn = document.getElementById('playBtn');
    const autoSlideCheckbox = document.getElementById('autoSlide');
    const slideSpeedInput = document.getElementById('slideSpeed');
    const targetFreqInput = document.getElementById('targetFreq');

    const analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;
    const freqData = new Uint8Array(analyser.frequencyBinCount);
    const timeData = new Uint8Array(analyser.fftSize);

    const specCanvas = document.getElementById('specCanvas');
    const specCtx = specCanvas.getContext('2d');

    const waveCanvas = document.getElementById('waveCanvas');
    const waveCtx = waveCanvas.getContext('2d');

    let minFreq = 20;
    let maxFreq = 20000;

    function getFrequencyRange() {
      const f0 = parseFloat(baseFreqInput.value);
      const f1 = parseFloat(freqInput.value);
      const n = parseInt(harmonicsInput.value);

      const freqs1 = Array.from({ length: n }, (_, i) => f0 * (i + 1));
      const freqs2 = Array.from({ length: n }, (_, i) => f1 * (i + 1));
      const all = freqs1.concat(freqs2);

      minFreq = Math.min(...all) * 0.9;
      maxFreq = Math.max(...all) * 1.1;
    }

    function drawSpectrogram() {
      if (!isPlaying) return;

      analyser.getByteFrequencyData(freqData);
      const w = specCanvas.width;
      const h = specCanvas.height;

      const imageData = specCtx.getImageData(1, 0, w - 1, h);
      specCtx.putImageData(imageData, 0, 0);

      const nyquist = ctx.sampleRate / 2;
      const logMin = Math.log10(minFreq);
      const logMax = Math.log10(maxFreq);
      const alpha = parseFloat(logScaleInput.value);

      for (let y = 0; y < h; y++) {
        let t = 1 - y / h;
        t = Math.pow(t, alpha);
        const logFreq = logMin + t * (logMax - logMin);
        const freq = Math.pow(10, logFreq);
        const bin = Math.floor(freq / nyquist * freqData.length);
        const value = freqData[bin] || 0;

        const color = `hsl(${240 - value * 1.2}, 100%, ${value / 255 * 50 + 25}%)`;
        specCtx.fillStyle = color;
        specCtx.fillRect(w - 1, y, 1, 1);
      }

      requestAnimationFrame(drawSpectrogram);
    }

    function drawWaveform() {
      if (!isPlaying) return;

      analyser.getByteTimeDomainData(timeData);
      const w = waveCanvas.width;
      const h = waveCanvas.height;

      waveCtx.clearRect(0, 0, w, h);
      waveCtx.beginPath();
      waveCtx.moveTo(0, h / 2);

      for (let i = 0; i < timeData.length; i++) {
        const x = i / timeData.length * w;
        const y = (timeData[i] / 255) * h;
        waveCtx.lineTo(x, y);
      }

      waveCtx.strokeStyle = '#0080ff';
      waveCtx.lineWidth = 1.2;
      waveCtx.stroke();

      requestAnimationFrame(drawWaveform);
    }

    function createHarmonics(freq) {
      const n = parseInt(harmonicsInput.value);
      const A0 = parseFloat(startAmpInput.value);
      const decay = parseFloat(decayInput.value);

      return Array.from({ length: n }, (_, i) => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = "sine";
        osc.frequency.value = freq * (i + 1);
        gain.gain.value = A0 / Math.pow(i + 1, decay);
        osc.connect(gain).connect(analyser).connect(ctx.destination);
        return { osc, gain };
      });
    }

    function start() {
      getFrequencyRange();
      const f0 = parseFloat(baseFreqInput.value);
      const f1 = parseFloat(freqInput.value);

      osc1 = createHarmonics(f0);
      osc2 = createHarmonics(f1);
      osc1.forEach(o => o.osc.start());
      osc2.forEach(o => o.osc.start());
      isPlaying = true;

      drawSpectrogram();
      drawWaveform();
      autoSlideLoop();
    }

    function stop() {
      osc1.concat(osc2).forEach(o => {
        try { o.osc.stop(); } catch (e) {}
      });
      osc1 = [];
      osc2 = [];
      isPlaying = false;
    }

    playBtn.onclick = () => {
      if (isPlaying) {
        stop();
        playBtn.textContent = "▶ Soita / Pysäytä";
      } else {
        start();
        playBtn.textContent = "⏹ Pysäytä";
      }
    };

    slider.oninput = freqInput.oninput = () => {
      freqInput.value = slider.value;
      slider.value = freqInput.value;
      updateFrequencies();
    };

    decayInput.oninput = () => {
      decayValueDisplay.textContent = parseFloat(decayInput.value).toFixed(1);
      updateFrequencies();
    };

    function updateFrequencies() {
      if (!isPlaying) return;
      const f1 = parseFloat(freqInput.value);
      const A0 = parseFloat(startAmpInput.value);
      const decay = parseFloat(decayInput.value);
      osc2.forEach((o, i) => {
        o.osc.frequency.value = f1 * (i + 1);
        o.gain.gain.value = A0 / Math.pow(i + 1, decay);
      });
      getFrequencyRange();
    }

    function autoSlideLoop() {
      if (!isPlaying) return;
      if (!autoSlideCheckbox.checked) {
        requestAnimationFrame(autoSlideLoop);
        return;
      }

      const current = parseFloat(freqInput.value);
      const target = parseFloat(targetFreqInput.value);
      const speed = parseFloat(slideSpeedInput.value);
      const step = speed / 60;

      let newVal = current;
      if (Math.abs(target - current) > step) {
        newVal += (target > current ? step : -step);
      } else {
        newVal = target;
      }

      freqInput.value = newVal.toFixed(2);
      slider.value = newVal.toFixed(2);
      updateFrequencies();

      requestAnimationFrame(autoSlideLoop);
    }
  </script>
</body>
</html>

